<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,maximum-scale=1,user-scalable=no" />
  <title>teboya_takahashi_prototype_v3_1 - Measurement Boost</title>
  <style>
    html,body{margin:0;padding:0;background:#111;color:#eee;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif}
    #app{min-height:100vh;display:flex;flex-direction:column;align-items:center;padding:10px;box-sizing:border-box;gap:8px}
    #topbar,#footer{width:min(980px,96vw);display:flex;gap:10px;flex-wrap:wrap;justify-content:space-between;align-items:center}
    .pill{background:#1c1c1c;border:1px solid #333;border-radius:999px;padding:6px 10px;font-size:14px;white-space:nowrap}
    #boardWrap{width:min(980px,96vw);display:flex;justify-content:center}
    canvas{width:100%;height:auto;max-width:980px;background:#0e0e0e;border:1px solid #2a2a2a;border-radius:12px;touch-action:none;display:block}
    button{background:#222;color:#eee;border:1px solid #3a3a3a;border-radius:10px;padding:8px 12px;cursor:pointer}
    #log{color:#aaa;font-size:12px;flex:1;min-width:220px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-align:center}
  </style>
</head>
<body>
<div id="app">
  <div id="topbar">
    <div class="pill" style="font-weight:700">FILE: <span id="fileLabel">teboya_takahashi_prototype_v3_1</span></div>
    <div class="pill">æ®‹ã‚Š <span id="timeLeft">45.0</span>s</div>
    <div class="pill">ã‚¹ã‚³ã‚¢ <span id="score">0</span></div>
    <div class="pill">ã‚³ãƒ³ãƒœ Ã—<span id="combo">1</span></div>
    <div class="pill">æˆåŠŸ <span id="successCount">0</span></div>
    <div class="pill">JUST <span id="justCount">0</span></div>
    <div class="pill">JUSTç‡ <span id="justRate">0</span>%</div>
    <div class="pill">ç·æä¾› <span id="totalServeCount">0</span></div>
    <div class="pill">æ³¨æ–‡ãƒŸã‚¹ <span id="wrongOrderCount">0</span></div>
    <div class="pill">ã®ã³ <span id="nobiCount">0</span></div>
    <div class="pill">å–ã‚Šé€ƒã— <span id="dropMissCount">0</span></div>
    <div class="pill">å¸°å®…å®¢ <span id="leftCustomerCount">0</span></div>
    <div class="pill">æœ€å¤§ã‚³ãƒ³ãƒœ <span id="maxCombo">1</span></div>
    <div class="pill" id="phasePill">é€šå¸¸</div>
    <div class="pill" id="phrase">æ¬¡ï¼</div>
  </div>
  <div id="boardWrap">
    <canvas id="game" width="980" height="720"></canvas>
  </div>
  <div id="footer">
    <button id="adBtn">ã‚¢ãƒ«ãƒã‚¤ãƒˆå¬å–šï¼ˆä»®ï¼‰</button>
    <div id="log">ãƒ­ã‚°ï¼šâ€”</div>
    <button id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
</div>

<script>
(() => {
  // v3.1: measurement boost (JUST/ã®ã³/ç·æä¾›/å–ã‚Šé€ƒã—/æœ€å¤§ã‚³ãƒ³ãƒœ)
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const ui = {
    timeLeft: document.getElementById('timeLeft'),
    score: document.getElementById('score'),
    combo: document.getElementById('combo'),
    successCount: document.getElementById('successCount'),
    justCount: document.getElementById('justCount'),
    justRate: document.getElementById('justRate'),
    totalServeCount: document.getElementById('totalServeCount'),
    wrongOrderCount: document.getElementById('wrongOrderCount'),
    nobiCount: document.getElementById('nobiCount'),
    dropMissCount: document.getElementById('dropMissCount'),
    leftCustomerCount: document.getElementById('leftCustomerCount'),
    maxCombo: document.getElementById('maxCombo'),
    phasePill: document.getElementById('phasePill'),
    phrase: document.getElementById('phrase'),
    log: document.getElementById('log'),
    resetBtn: document.getElementById('resetBtn'),
    adBtn: document.getElementById('adBtn')
  };

  const GAME_TIME = 45;
  const LANE_COUNT = 4;
  const OVERCOOK = 3.6;

  // åŸºæœ¬æ¹§ãé–“éš”ï¼ˆçµ‚ç›¤ã§çŸ­ç¸®ï¼‰
  const SPAWN_NORMAL = [0.75, 1.15];
  const SPAWN_RUSH   = [0.45, 0.80];

  // QoLï¼ˆå—ã‘å–ã‚Šæ”¹å–„ï¼‰
  const ACTIVE_CATCH_RADIUS_BONUS = 16;   // éººã®ç›´æ¥ã‚¿ãƒƒãƒåˆ¤å®šæ‹¡å¤§
  const SPOUT_CATCH_RADIUS = 54;          // æ’å‡ºå£ä»˜è¿‘ãªã‚‰éººã‚’ã¤ã‹ã¿ã‚„ã™ãã™ã‚‹
  const BASKET_SNAP_MARGIN = 28;          // ã¦ã¼è¿‘å‚ã§å¸ç€åˆ¤å®šï¼ˆçŸ©å½¢å¤–ã§ã‚‚OKï¼‰
  const MISSED_NOODLE_GRACE = 0.55;       // å–ã‚Šé€ƒã—çŒ¶äºˆ

  const HARDNESS_TABLE = [
    { key:'ã‹ãŸ',   a:0.0, b:1.2, justA:0.4, justB:0.8, color:'#d6b85c' },
    { key:'ãµã¤ã†', a:1.2, b:2.4, justA:1.6, justB:2.0, color:'#65c8b7' },
    { key:'ã‚„ã‚',   a:2.4, b:3.6, justA:2.8, justB:3.2, color:'#8fb8ff' },
  ];
  const COLOR_NOBI = '#ff9d9d';

  const CUSTOMER_ICONS = ['ğŸ™‚','ğŸ˜','ğŸ˜‘','ğŸ˜„','ğŸ§¢','ğŸ‘“','ğŸ§‘','ğŸ‘¨'];
  const CUSTOMER_NAMES = ['å®¢A','å®¢B','å®¢C','å¸¸é€£','ä¼šç¤¾å“¡','å­¦ç”Ÿ','ãƒ¢ãƒ–å®¢','ãŠå®¢ã•ã‚“'];

  let last = performance.now();
  let t = 0;
  let timeLeft = GAME_TIME;
  let score = 0;
  let combo = 1;
  let comboStreak = 0;
  let stats = { success:0, just:0, totalServe:0, wrongOrder:0, nobi:0, dropMiss:0, leftCustomer:0, maxCombo:1 };
  let phraseTimer = 0;
  let spawnTimer = 0;

  let lanes = [];
  let activeNoodle = null;
  let flying = [];
  let impacts = [];
  let laneToasts = [];
  let pointer = { down:false, id:null, x:0, y:0 };

  function rnd(a,b){ return a + Math.random()*(b-a); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function d2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

  function currentSpawnRange() {
    return timeLeft <= 15 ? SPAWN_RUSH : SPAWN_NORMAL;
  }
  function currentRushMultiplier() {
    return timeLeft <= 15 ? 1.18 : 1.0; // å®¢ã®å¾…ã¡æ¸›å°‘ã‚’å°‘ã—ã ã‘é€Ÿã
  }

  function nextSpawnDelay() {
    const r = currentSpawnRange();
    return rnd(r[0], r[1]);
  }

  function getLayout() {
    const W = canvas.width, H = canvas.height;
    const legendW = 150, boardPad = 18;
    const playX = boardPad, playY = boardPad;
    const playW = W - legendW - boardPad*2;
    const playH = H - boardPad*2;

    const headerLineY = playY + 28;
    const customerRowY = playY + 78;

    const basketH = 110;
    const basketY = playY + playH - basketH - 6;
    const laneGap = 14;
    const laneW = (playW - laneGap*(LANE_COUNT-1)) / LANE_COUNT;

    const lanesGeo = [];
    for (let i=0;i<LANE_COUNT;i++){
      const x = playX + i*(laneW + laneGap);
      lanesGeo.push({
        i, x, w: laneW, centerX: x + laneW/2,
        topY: customerRowY + 18, bottomY: basketY - 12,
        basket: {
          x: x + 8, y: basketY, w: laneW - 16, h: basketH,
          cx: x + laneW/2, cy: basketY + basketH*0.48
        },
        customerFaceX: x + laneW/2, customerFaceY: customerRowY,
        targetX: x + laneW/2, targetY: customerRowY + 14
      });
    }

    const spout = { x: playX + playW + 8, y: playY + playH * 0.54, w: 54, h: 16 };
    const legend = { x: W - legendW - boardPad, y: playY + 10, w: legendW, h: 150 };

    return {W,H,boardPad,playX,playY,playW,playH,headerLineY,customerRowY,basketY,lanesGeo,spout,legend};
  }

  function randomCustomer() {
    const idx = Math.floor(Math.random()*CUSTOMER_ICONS.length);
    return { icon: CUSTOMER_ICONS[idx], name: CUSTOMER_NAMES[idx], mood:'normal' };
  }

  function newOrder() {
    const hard = HARDNESS_TABLE[Math.floor(Math.random()*HARDNESS_TABLE.length)];
    return { target: hard.key, patience: rnd(7, 11), patienceMax: 11, customer: randomCustomer(), special: 'é€šå¸¸' };
  }

  function initLanes() {
    lanes = [];
    laneToasts = [];
    for (let i=0;i<LANE_COUNT;i++){
      lanes.push({
        order: newOrder(),
        noodlesInBasket: [],
        auto: { enabled:false, timeLeft:0, usesLeft:0 },
        reaction: { text:'', timer:0, kind:'none' }
      });
      laneToasts.push({ timer:0, kind:'none', req:'', got:'', text:'' });
    }
  }

  function resetGame() {
    t=0; timeLeft=GAME_TIME; score=0; combo=1; comboStreak=0;
    stats = { success:0, just:0, totalServe:0, wrongOrder:0, nobi:0, dropMiss:0, leftCustomer:0, maxCombo:1 };
    phraseTimer=0; spawnTimer=nextSpawnDelay();
    activeNoodle = null; flying=[]; impacts=[]; initLanes();
    setPhrase('æ¬¡ï¼',700); log('ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ'); syncHud();
  }

  function syncHud() {
    ui.timeLeft.textContent = timeLeft.toFixed(1);
    ui.score.textContent = String(score);
    ui.combo.textContent = String(combo);
    ui.successCount.textContent = String(stats.success);
    ui.justCount.textContent = String(stats.just);
    ui.totalServeCount.textContent = String(stats.totalServe);
    const jr = stats.totalServe > 0 ? Math.round((stats.just / stats.totalServe) * 100) : 0;
    ui.justRate.textContent = String(jr);
    ui.wrongOrderCount.textContent = String(stats.wrongOrder);
    ui.nobiCount.textContent = String(stats.nobi);
    ui.dropMissCount.textContent = String(stats.dropMiss);
    ui.leftCustomerCount.textContent = String(stats.leftCustomer);
    ui.maxCombo.textContent = String(stats.maxCombo);
    ui.phasePill.textContent = timeLeft <= 15 ? 'çµ‚ç›¤ãƒ©ãƒƒã‚·ãƒ¥' : 'é€šå¸¸';
  }
  function log(msg){ ui.log.textContent = 'ãƒ­ã‚°ï¼š' + msg; }
  function setPhrase(text, ms=900){ ui.phrase.textContent=text; phraseTimer = ms/1000; }

  function hardnessByTime(sec) {
    if (sec >= OVERCOOK) return { key:'ã®ã³', ok:false, just:false, color:COLOR_NOBI };
    const h = HARDNESS_TABLE.find(x => sec >= x.a && sec < x.b) || HARDNESS_TABLE[0];
    const just = sec >= h.justA && sec <= h.justB;
    return { key:h.key, ok:true, just, color:h.color };
  }

  function setLaneToast(laneIndex, kind, req, got, text) {
    laneToasts[laneIndex] = { timer:1.1, kind, req, got, text };
  }

  function setLaneReaction(laneIndex, kind) {
    let text = '';
    if (kind==='just') text='â—';
    else if (kind==='ok') text='â—‹';
    else if (kind==='miss') text='Ã—';
    else if (kind==='nobi') text='!!';
    lanes[laneIndex].reaction = { text, timer:0.7, kind };
  }

  function addImpact(x,y,kind){
    impacts.push({ x,y,r:8,life:0.35,maxLife:0.35,kind });
  }

  function canvasPoint(e){
    const r = canvas.getBoundingClientRect();
    return { x:(e.clientX-r.left)*(canvas.width/r.width), y:(e.clientY-r.top)*(canvas.height/r.height) };
  }

  function tryCatchActiveNoodleByExpandedArea(px, py, geo) {
    if (!activeNoodle) return false;
    // ç›´æ¥ã‚¿ãƒƒãƒï¼ˆæ‹¡å¤§ï¼‰
    if (d2(px, py, activeNoodle.x, activeNoodle.y) <= (activeNoodle.r + ACTIVE_CATCH_RADIUS_BONUS)**2) {
      activeNoodle.dragging = true;
      return true;
    }
    // æ’å‡ºå£ä»˜è¿‘ãªã‚‰æ´ã‚ã‚‹ï¼ˆåˆå‹•æ•‘æ¸ˆï¼‰
    const sx = geo.spout.x + geo.spout.w*0.5;
    const sy = geo.spout.y + geo.spout.h*0.5;
    if (d2(px, py, sx, sy) <= SPOUT_CATCH_RADIUS*SPOUT_CATCH_RADIUS) {
      activeNoodle.dragging = true;
      activeNoodle.x = px;
      activeNoodle.y = py;
      return true;
    }
    return false;
  }

  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    pointer.down = true;
    pointer.id = e.pointerId;
    const p = canvasPoint(e); pointer.x=p.x; pointer.y=p.y;
    const geo = getLayout();

    // å…ˆã«ã¦ã¼å†…éººã®ç™ºå°„åˆ¤å®š
    for (let i=0;i<LANE_COUNT;i++){
      const arr = lanes[i].noodlesInBasket;
      for (let j=arr.length-1;j>=0;j--){
        const n = arr[j];
        if (d2(p.x,p.y,n.x,n.y) <= n.r*n.r){
          fireNoodleFromBasket(i, j, geo);
          return;
        }
      }
    }

    // æ’å‡ºéººã®æ´ã¿ã‚„ã™ã•æ”¹å–„
    if (activeNoodle && tryCatchActiveNoodleByExpandedArea(p.x, p.y, geo)) return;
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!pointer.down || e.pointerId !== pointer.id) return;
    const p = canvasPoint(e); pointer.x=p.x; pointer.y=p.y;
    if (activeNoodle && activeNoodle.dragging) {
      activeNoodle.x = p.x;
      activeNoodle.y = p.y;
    }
  });

  canvas.addEventListener('pointerup', (e) => {
    if (e.pointerId !== pointer.id) return;
    pointer.down = false;
    const p = canvasPoint(e); pointer.x=p.x; pointer.y=p.y;

    if (activeNoodle && activeNoodle.dragging){
      activeNoodle.dragging = false;
      const geo = getLayout();

      for (let i=0;i<LANE_COUNT;i++){
        const b = geo.lanesGeo[i].basket;
        // ã¦ã¼å¸ç€åˆ¤å®šï¼ˆå°‘ã—å¤–ã§ã‚‚æŠ•å…¥ã§ãã‚‹ï¼‰
        if (p.x >= b.x - BASKET_SNAP_MARGIN && p.x <= b.x+b.w + BASKET_SNAP_MARGIN &&
            p.y >= b.y - BASKET_SNAP_MARGIN && p.y <= b.y+b.h + BASKET_SNAP_MARGIN) {
          lanes[i].noodlesInBasket.push({
            cook: 0,
            x: b.cx + rnd(-16, 16),
            y: b.cy + rnd(-14, 14),
            r: 12
          });
          activeNoodle = null;
          log(`ã¦ã¼${i+1}ã«æŠ•å…¥ï¼ˆå¸ç€ï¼‰`);
          setPhrase('æ¬¡ï¼', 500);
          return;
        }
      }

      // æŠ•å…¥å¤±æ•—æ™‚ã‚‚å³æ¶ˆãˆãªã„ï¼ˆçŒ¶äºˆï¼‰
      activeNoodle.missGrace = MISSED_NOODLE_GRACE;
      log('ã¦ã¼ã«å…¥ã‚‰ãšâ€¦ï¼ˆçŒ¶äºˆã‚ã‚Šï¼‰');
    }
  });

  function spawnNoodle(geo){
    activeNoodle = {
      x: geo.spout.x + geo.spout.w * 0.5,
      y: geo.spout.y + geo.spout.h * 0.5,
      r: 15,
      dragging: false,
      vx: -24,
      missGrace: 0
    };
  }

  function award(base, isJust){
    score += base * combo;
    comboStreak++;
    if (comboStreak % 5 === 0) combo = Math.min(9, combo + 1);
    if (combo > stats.maxCombo) stats.maxCombo = combo;
    if (isJust) setPhrase('ç¡¬ã•ãƒ¨ã‚·ï¼', 900);
    syncHud();
  }

  function penalty(p){
    score = Math.max(0, score - p);
    combo = 1;
    comboStreak = 0;
    syncHud();
  }

  function nextOrder(laneIndex){ lanes[laneIndex].order = newOrder(); }

  function queueFlyingNoodle(sx,sy,tx,ty,laneIndex,outcome){
    const dx = tx-sx, dy = ty-sy;
    const len = Math.max(1, Math.hypot(dx,dy));
    const speed = 760;
    flying.push({ x:sx,y:sy,r:10, vx:dx/len*speed, vy:dy/len*speed, tx,ty, laneIndex, outcome, arrived:false });
  }

  function fireNoodleFromBasket(laneIndex, noodleIndex, geo){
    const lane = lanes[laneIndex];
    const n = lane.noodlesInBasket.splice(noodleIndex, 1)[0];
    const h = hardnessByTime(n.cook);
    const order = lane.order;
    const laneGeo = geo.lanesGeo[laneIndex];

    let outcome = { kind:'miss', req:order.target, got:h.key, scoreDelta:0 };
    if (!h.ok) { outcome.kind='nobi'; outcome.scoreDelta=-15; }
    else if (h.key === order.target) {
      if (h.just) { outcome.kind='just'; outcome.scoreDelta=+20*combo; }
      else { outcome.kind='ok'; outcome.scoreDelta=+10*combo; }
    } else {
      outcome.kind='miss'; outcome.scoreDelta=-10;
    }
    queueFlyingNoodle(n.x, n.y, laneGeo.targetX, laneGeo.targetY, laneIndex, outcome);
  }

  function applyOutcomeAtArrival(laneIndex, outcome){
    const lane = lanes[laneIndex];
    const order = lane.order;

    if (outcome.kind === 'nobi'){
      stats.totalServe++;
      stats.nobi++;
      log(`ã®ã³ï¼ˆã¦ã¼${laneIndex+1}ï¼‰`);
      setPhrase('ç„¦ã‚‹ã¨â€œã®ã³â€ã‚‹', 1200);
      penalty(15);
      order.patience = Math.max(0, order.patience - 1.5);
      setLaneReaction(laneIndex, 'nobi');
      setLaneToast(laneIndex, 'nobi', outcome.req, outcome.got, `ã®ã³ (${outcome.got})`);
      return;
    }
    if (outcome.kind === 'just'){
      stats.totalServe++;
      stats.just++;
      log(`ã‚¸ãƒ£ã‚¹ãƒˆæˆåŠŸï¼ˆã¦ã¼${laneIndex+1}ï¼‰`);
      stats.success++;
      award(20, true);
      setLaneReaction(laneIndex, 'just');
      setLaneToast(laneIndex, 'just', outcome.req, outcome.got, `JUST! ${outcome.got}`);
      nextOrder(laneIndex);
      return;
    }
    if (outcome.kind === 'ok'){
      stats.totalServe++;
      log(`æˆåŠŸï¼ˆã¦ã¼${laneIndex+1}ï¼‰`);
      stats.success++;
      award(10, false);
      setLaneReaction(laneIndex, 'ok');
      setLaneToast(laneIndex, 'ok', outcome.req, outcome.got, `OK ${outcome.got}`);
      nextOrder(laneIndex);
      return;
    }

    stats.totalServe++;
    log(`ç¡¬ã•ãƒŸã‚¹ï¼ˆ${outcome.got}â†’${outcome.req}ï¼‰`);
    stats.wrongOrder++;
    penalty(10);
    order.patience = Math.max(0, order.patience - 2.0);
    setLaneReaction(laneIndex, 'miss');
    setLaneToast(laneIndex, 'miss', outcome.req, outcome.got, `MISS ${outcome.got}`);
  }

  function update(dt){
    const geo = getLayout();

    if (phraseTimer > 0){ phraseTimer -= dt; if (phraseTimer <= 0) ui.phrase.textContent = 'æ¬¡ï¼'; }

    if (timeLeft > 0) timeLeft = Math.max(0, timeLeft - dt);
    syncHud();

    // çµ‚ç›¤çªå…¥ã§ä¸€åº¦ã ã‘æ›ã‘å£°
    if (timeLeft <= 15 && !update._rushAnnounced) {
      update._rushAnnounced = true;
      setPhrase('ãƒ©ãƒƒã‚·ãƒ¥ï¼', 1000);
      log('çµ‚ç›¤ãƒ©ãƒƒã‚·ãƒ¥é–‹å§‹');
    }
    if (timeLeft > 15) update._rushAnnounced = false;

    spawnTimer -= dt;
    if (timeLeft > 0 && spawnTimer <= 0){
      if (!activeNoodle) spawnNoodle(geo);
      spawnTimer = nextSpawnDelay();
    }

    // æ’å‡ºéººæŒ™å‹• + å–ã‚Šé€ƒã—çŒ¶äºˆ
    if (activeNoodle && !activeNoodle.dragging){
      activeNoodle.x += activeNoodle.vx * dt;
      activeNoodle.x = clamp(activeNoodle.x, geo.spout.x - 80, geo.spout.x + 40);
      activeNoodle.y += Math.sin(t * 3.2) * 8 * dt;
      activeNoodle.y = clamp(activeNoodle.y, geo.spout.y - 20, geo.spout.y + 20);

      if (activeNoodle.missGrace > 0) {
        activeNoodle.missGrace = Math.max(0, activeNoodle.missGrace - dt);
      }
      // å·¦ã«æµã‚Œãã£ã¦çŒ¶äºˆã‚‚çµ‚äº†ã—ãŸã‚‰æ¶ˆãˆã‚‹
      if (activeNoodle.x <= geo.spout.x - 78 && activeNoodle.missGrace <= 0) {
        log('éººã‚’å–ã‚Šé€ƒã—ã¾ã—ãŸ');
        stats.dropMiss++;
        penalty(2);
        activeNoodle = null;
      }
    }

    for (let i=0;i<LANE_COUNT;i++){
      const lane = lanes[i];
      const b = geo.lanesGeo[i].basket;

      if (timeLeft > 0){
        lane.order.patience = Math.max(0, lane.order.patience - dt * currentRushMultiplier());
        if (lane.order.patience === 0){
          penalty(5);
          stats.leftCustomer++;
          log(`ãƒ¬ãƒ¼ãƒ³${i+1} å®¢ãŒå¸°ã£ãŸâ€¦`);
          lane.order = newOrder();
        }
      }

      for (const n of lane.noodlesInBasket){
        n.cook += dt;
        n.x = clamp(n.x + Math.sin((t+n.cook)*2.0) * 2.0 * dt, b.x+12, b.x+b.w-12);
        n.y = clamp(n.y + Math.cos((t+n.cook)*1.7) * 2.0 * dt, b.y+20, b.y+b.h-20);
      }

      if (lane.auto.enabled && timeLeft > 0){
        lane.auto.timeLeft = Math.max(0, lane.auto.timeLeft - dt);
        if (lane.auto.timeLeft <= 0) lane.auto.enabled = false;

        if (lane.auto.usesLeft > 0 && lane.noodlesInBasket.length > 0){
          let idx = 0;
          for (let j=1;j<lane.noodlesInBasket.length;j++){
            if (lane.noodlesInBasket[j].cook > lane.noodlesInBasket[idx].cook) idx = j;
          }
          if (Math.random() < dt * 1.25){
            fireNoodleFromBasket(i, idx, geo);
            lane.auto.usesLeft--;
          }
        }
      }

      if (lane.reaction.timer > 0) lane.reaction.timer = Math.max(0, lane.reaction.timer - dt);
      if (laneToasts[i].timer > 0) laneToasts[i].timer = Math.max(0, laneToasts[i].timer - dt);
    }

    for (let i=flying.length-1;i>=0;i--){
      const f = flying[i];
      if (!f.arrived){
        f.x += f.vx * dt;
        f.y += f.vy * dt;
        if (d2(f.x, f.y, f.tx, f.ty) <= 14*14){
          f.arrived = true;
          addImpact(f.tx, f.ty, f.outcome.kind);
          applyOutcomeAtArrival(f.laneIndex, f.outcome);
          flying.splice(i,1);
          continue;
        }
      }
    }

    for (let i=impacts.length-1;i>=0;i--){
      const im = impacts[i];
      im.life -= dt;
      im.r += 90 * dt;
      if (im.life <= 0) impacts.splice(i,1);
    }
  }

  function outcomeColor(kind){
    if (kind==='just') return '#ffe17a';
    if (kind==='ok') return '#7dd3fc';
    if (kind==='miss') return '#ff8b8b';
    if (kind==='nobi') return '#ff6262';
    return '#ccc';
  }

  function drawPatienceGauge(lg, order){
    const ratio = clamp(order.patience / order.patienceMax, 0, 1);
    const cx = lg.customerFaceX, cy = lg.customerFaceY, r = 30;
    const start = -Math.PI/2;
    const end = start + Math.PI*2*ratio;

    // èƒŒæ™¯ãƒªãƒ³ã‚°
    ctx.save();
    ctx.lineWidth = 5;
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();

    // è‰²å¤‰åŒ–ï¼ˆç·‘â†’é»„â†’èµ¤ï¼‰
    let col = '#58d68d';
    if (ratio < 0.55) col = '#f1c40f';
    if (ratio < 0.28) col = '#ff6b6b';
    if (ratio < 0.18 && Math.floor(t*10)%2===0) col = '#ffd1d1'; // ç‚¹æ»…æ°—å‘³
    ctx.strokeStyle = col;
    ctx.beginPath(); ctx.arc(cx, cy, r, start, end, false); ctx.stroke();
    ctx.restore();
  }

  function drawCustomerReaction(i, lg){
    const r = lanes[i].reaction;
    if (!r || r.timer <= 0) return;
    const p = r.timer / 0.7;
    const alpha = clamp(p, 0, 1);
    const y = lg.customerFaceY - 34 - (1-p) * 8;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    roundRectFill(ctx, lg.customerFaceX - 18, y - 18, 36, 22, 6);
    ctx.fillStyle = outcomeColor(r.kind);
    ctx.font = '18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(r.text, lg.customerFaceX, y - 2);
    ctx.restore();
  }

  function drawLaneToast(i, lg, headerLineY){
    const toast = laneToasts[i];
    if (!toast || toast.timer <= 0) return;
    const p = toast.timer / 1.1;
    const alpha = clamp(Math.min(1, p * 1.4), 0, 1);

    const boxW = 104, boxH = 34;
    const x = lg.centerX - boxW/2;
    const y = headerLineY + 10 - (1-p) * 6;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = 'rgba(12,12,12,0.85)';
    ctx.strokeStyle = outcomeColor(toast.kind);
    ctx.lineWidth = 2;
    roundRectFillStroke(ctx, x, y, boxW, boxH, 8);
    ctx.fillStyle = outcomeColor(toast.kind);
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(toast.text, lg.centerX, y + 14);
    ctx.fillStyle = '#ddd';
    ctx.font = '10px sans-serif';
    ctx.fillText(`æ³¨æ–‡:${toast.req} / å±Š:${toast.got}`, lg.centerX, y + 28);
    ctx.restore();
  }

  function drawImpacts(){
    for (const im of impacts){
      const a = clamp(im.life / im.maxLife, 0, 1);
      const col = outcomeColor(im.kind);
      ctx.save();
      ctx.globalAlpha = a * 0.9;
      ctx.strokeStyle = col;
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(im.x, im.y, im.r, 0, Math.PI*2); ctx.stroke();
      ctx.globalAlpha = a * 0.5;
      ctx.fillStyle = col;
      ctx.beginPath(); ctx.arc(im.x, im.y, 4, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  function drawLegend(legend){
    const x = legend.x + 10, y = legend.y + 14;
    ctx.fillStyle = '#ddd'; ctx.font = '16px sans-serif'; ctx.textAlign='left';
    ctx.fillText('ç¡¬ã•è‰²', x, y);

    const rows = [
      { label:'ã‹ãŸ', color:HARDNESS_TABLE[0].color },
      { label:'æ™®',   color:HARDNESS_TABLE[1].color },
      { label:'ã‚„ã‚', color:HARDNESS_TABLE[2].color },
      { label:'ã®ã³', color:COLOR_NOBI }
    ];
    let cy = y + 28;
    for (const r of rows){
      ctx.fillStyle = r.color; ctx.fillRect(x, cy-12, 18, 12);
      ctx.strokeStyle = '#555'; ctx.strokeRect(x, cy-12, 18, 12);
      ctx.fillStyle = '#ddd'; ctx.font='14px sans-serif';
      ctx.fillText(`${r.label} â—‹è‰²`, x+28, cy-1);
      cy += 28;
    }
    cy += 8;
    ctx.fillStyle = '#aaa'; ctx.font='12px sans-serif';
    ctx.fillText('ç™½ã„è¼ª = ã‚¸ãƒ£ã‚¹ãƒˆ', x, cy);
    cy += 20; ctx.fillText('â—/â—‹/Ã— = åˆ¤å®š', x, cy);
    cy += 20; ctx.fillText('å®¢ãƒªãƒ³ã‚° = å¾…ã¡', x, cy);
    if (timeLeft <= 15){
      cy += 24;
      ctx.fillStyle = '#ffcc66';
      ctx.fillText('çµ‚ç›¤ï¼šæ’å‡ºâ†‘', x, cy);
    }
  }

  function draw(){
    const geo = getLayout();
    const {W,H,playX,playY,playW,playH,lanesGeo,customerRowY,headerLineY,legend,spout} = geo;

    ctx.clearRect(0,0,W,H);
    ctx.strokeStyle = '#3a3a3a'; ctx.lineWidth = 2; roundRectStroke(ctx, 6, 6, W-12, H-12, 10);
    ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = 1.5; roundRectStroke(ctx, playX, playY, playW, playH, 8);
    ctx.strokeStyle = '#2a2a2a'; roundRectStroke(ctx, legend.x, playY, legend.w, playH, 8);

    ctx.strokeStyle = '#242424'; ctx.setLineDash([4,6]);
    ctx.beginPath(); ctx.moveTo(playX + 8, customerRowY + 28); ctx.lineTo(playX + playW - 8, customerRowY + 28); ctx.stroke();
    ctx.setLineDash([]);

    for (const lg of lanesGeo){
      ctx.strokeStyle = '#262626'; ctx.setLineDash([6,10]);
      ctx.beginPath(); ctx.moveTo(lg.centerX, customerRowY + 28); ctx.lineTo(lg.centerX, lg.bottomY); ctx.stroke();
      ctx.setLineDash([]);
    }

    // ä¸Šæ®µ:æ³¨æ–‡
    for (let i=0;i<LANE_COUNT;i++){
      const lg = lanesGeo[i], order = lanes[i].order;
      ctx.fillStyle = '#ddd'; ctx.font = '20px sans-serif'; ctx.textAlign='center';
      ctx.fillText(order.target, lg.centerX, headerLineY);
      drawLaneToast(i, lg, headerLineY);
    }

    // å®¢ã‚¢ã‚¤ã‚³ãƒ³+å¾…ã¡ã‚²ãƒ¼ã‚¸
    for (let i=0;i<LANE_COUNT;i++){
      const lg = lanesGeo[i], order = lanes[i].order;

      drawPatienceGauge(lg, order);

      ctx.fillStyle = '#191919'; ctx.strokeStyle = '#666'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(lg.customerFaceX, lg.customerFaceY, 24, 0, Math.PI*2); ctx.fill(); ctx.stroke();

      ctx.font='20px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle='#f2f2f2';
      ctx.fillText(order.customer.icon, lg.customerFaceX, lg.customerFaceY+1);
      ctx.textBaseline='alphabetic';

      ctx.fillStyle='#999'; ctx.font='11px sans-serif';
      ctx.fillText(`${order.patience.toFixed(1)}s`, lg.centerX, lg.customerFaceY + 44);

      drawCustomerReaction(i, lg);
    }

    // ã¦ã¼
    for (let i=0;i<LANE_COUNT;i++){
      const lg = lanesGeo[i], b = lg.basket;
      ctx.fillStyle='#141414'; ctx.strokeStyle='#555'; ctx.lineWidth=2;
      roundRectFillStroke(ctx, b.x, b.y, b.w, b.h, 8);

      ctx.fillStyle='#d8d8d8'; ctx.font='14px sans-serif'; ctx.textAlign='center';
      ctx.fillText(`ã¦ã¼ ${i+1}`, b.cx, b.y + 22);

      for (const n of lanes[i].noodlesInBasket){
        const h = hardnessByTime(n.cook);
        ctx.fillStyle = h.color;
        ctx.beginPath(); ctx.arc(n.x, n.y, n.r, 0, Math.PI*2); ctx.fill();

        if (h.just){
          ctx.strokeStyle='#fff'; ctx.globalAlpha=0.35; ctx.lineWidth=3;
          ctx.beginPath(); ctx.arc(n.x,n.y,n.r+3,0,Math.PI*2); ctx.stroke();
          ctx.globalAlpha=1;
        }
      }

      // å¸ç€å¯è¦–åŒ–ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã¿ï¼‰
      if (activeNoodle && activeNoodle.dragging){
        ctx.save();
        ctx.strokeStyle='rgba(125,211,252,0.35)';
        ctx.lineWidth=2;
        ctx.setLineDash([6,6]);
        roundRectStroke(ctx, b.x - BASKET_SNAP_MARGIN, b.y - BASKET_SNAP_MARGIN,
          b.w + BASKET_SNAP_MARGIN*2, b.h + BASKET_SNAP_MARGIN*2, 10);
        ctx.restore();
      }
    }

    // æ’å‡ºå£
    ctx.fillStyle='#2d2d2d'; ctx.strokeStyle='#777'; ctx.lineWidth=1.5;
    ctx.fillRect(spout.x,spout.y,spout.w,spout.h); ctx.strokeRect(spout.x,spout.y,spout.w,spout.h);
    ctx.fillStyle='#ddd'; ctx.font='14px sans-serif'; ctx.textAlign='right';
    ctx.fillText('ã‚ã‚“å‡ºã‚‹', spout.x - 8, spout.y + 13);

    // æ’å‡ºå£ã®ã‚­ãƒ£ãƒƒãƒè£œåŠ©ãƒªãƒ³ã‚°ï¼ˆæ’å‡ºéººãŒã‚ã‚‹æ™‚ï¼‰
    if (activeNoodle && !activeNoodle.dragging){
      const sx = spout.x + spout.w*0.5, sy = spout.y + spout.h*0.5;
      ctx.save();
      ctx.strokeStyle='rgba(255,255,255,0.12)';
      ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.arc(sx, sy, SPOUT_CATCH_RADIUS, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
    }

    // æ’å‡ºä¸­ã®éºº
    if (activeNoodle){
      ctx.fillStyle='#f4f4f4'; ctx.strokeStyle='#333'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(activeNoodle.x, activeNoodle.y, activeNoodle.r, 0, Math.PI*2); ctx.fill(); ctx.stroke();

      if (activeNoodle.missGrace > 0){
        ctx.save();
        ctx.globalAlpha = 0.65;
        ctx.fillStyle='#ffcf8b';
        ctx.font='11px sans-serif';
        ctx.textAlign='center';
        ctx.fillText('ã‚‚ã†ä¸€åº¦ã¤ã‹ã‚ã‚‹', activeNoodle.x, activeNoodle.y - 22);
        ctx.restore();
      }
    }

    // é£›è¡Œéºº
    for (const f of flying){
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = outcomeColor(f.outcome.kind);
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(f.x - f.vx*0.03, f.y - f.vy*0.03); ctx.lineTo(f.x, f.y); ctx.stroke();
      ctx.restore();

      ctx.fillStyle='#fff';
      ctx.beginPath(); ctx.arc(f.x,f.y,f.r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=outcomeColor(f.outcome.kind); ctx.lineWidth=2; ctx.stroke();
    }

    drawImpacts();
    drawLegend(legend);

    if (timeLeft <= 0){
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle='#fff'; ctx.font='28px sans-serif'; ctx.textAlign='center';
      ctx.fillText('æ™‚é–“çµ‚äº†', W/2, H/2 - 10);
      ctx.font='18px sans-serif'; ctx.fillText(`ã‚¹ã‚³ã‚¢ ${score}`, W/2, H/2 + 24);
      ctx.font='15px sans-serif';
      ctx.fillText(`æˆåŠŸ ${stats.success} / JUST ${stats.just} / ç·æä¾› ${stats.totalServe} / æ³¨æ–‡ãƒŸã‚¹ ${stats.wrongOrder} / ã®ã³ ${stats.nobi}`, W/2, H/2 + 52);
      ctx.fillText(`å–ã‚Šé€ƒã— ${stats.dropMiss} / å¸°å®…å®¢ ${stats.leftCustomer} / æœ€å¤§ã‚³ãƒ³ãƒœ ${stats.maxCombo}`, W/2, H/2 + 74);
    }
  }

  function roundRectStroke(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath(); ctx.stroke();
  }
  function roundRectFill(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath(); ctx.fill();
  }
  function roundRectFillStroke(ctx,x,y,w,h,r){ roundRectFill(ctx,x,y,w,h,r); ctx.stroke(); }

  function frame(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now; t += dt;
    update(dt); draw();
    requestAnimationFrame(frame);
  }

  ui.resetBtn.addEventListener('click', resetGame);
  ui.adBtn.addEventListener('click', () => {
    lanes[0].auto.enabled = true;
    lanes[0].auto.timeLeft = 12;
    lanes[0].auto.usesLeft = 6;
    log('ã‚¢ãƒ«ãƒã‚¤ãƒˆï¼ˆä»®ï¼‰ï¼šã¦ã¼1ã‚’è£œåŠ©');
  });

  resetGame();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
