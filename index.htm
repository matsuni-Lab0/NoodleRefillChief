<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ã¦ã¼å±‹ã®æ›¿ç‰ä¿‚é•· é«˜æ©‹ã•ã‚“ï¼ˆä»®ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ï¼‰</title>
  <style>
    html,body{
      margin:0;padding:0;background:#111;color:#eee;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic",sans-serif;
    }
    #wrap{display:flex;flex-direction:column;min-height:100vh}

    #hud{
      padding:10px 12px;background:#161616;position:sticky;top:0;z-index:10;
      border-bottom:1px solid #232323;
    }
    #toprow{
      display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;
      margin-bottom:8px;
    }
    .pill{
      background:#222;border:1px solid #333;border-radius:999px;padding:6px 10px;
      font-size:14px;white-space:nowrap;
    }

    /* â˜…ä¸Šæ®µï¼æŒ‡ç¤ºã€ä¸‹æ®µï¼å®¢ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆåŒä¸€åˆ—ã‚°ãƒªãƒƒãƒ‰ï¼‰ */
    #orderInstructions,
    #customerIcons{
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:8px;
    }
    #customerIcons{ margin-top:6px; }

    .orderCard{
      background:#1d1d1d;border:1px solid #333;border-radius:12px;padding:8px;
    }
    .orderTitle{
      display:flex;align-items:center;justify-content:space-between;
      font-size:12px;color:#cfcfcf;margin-bottom:6px;
    }
    .orderHard{
      font-size:18px;font-weight:700;line-height:1.2;
    }
    .orderMeta{
      margin-top:4px;font-size:12px;color:#aaa;
    }
    .badge{
      font-size:12px;background:#2a2a2a;border:1px solid #444;border-radius:8px;padding:2px 6px;color:#ddd;
    }

    .customerCard{
      background:#181818;border:1px solid #2e2e2e;border-radius:12px;
      padding:8px; display:flex; align-items:center; gap:8px; min-height:48px;
    }
    .customerAvatar{
      width:30px;height:30px;border-radius:50%;
      background:#2b2b2b;border:1px solid #444;
      display:flex;align-items:center;justify-content:center;
      font-size:14px;
      flex:0 0 auto;
    }
    .customerText{
      font-size:12px;color:#cfcfcf;line-height:1.2;
    }
    .customerName{font-weight:700;color:#eee;font-size:13px}

    #tip{
      font-size:12px;color:#9bd;opacity:.95;margin-top:8px;
    }

    #canvasWrap{
      flex:1;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      padding:10px 0 0;
    }
    canvas{
      width:min(520px, 96vw);
      height:auto;
      touch-action:none;
      display:block;
      background:linear-gradient(#101010,#0b0b0b);
      border:1px solid #222;
      border-radius:14px;
    }

    #footer{
      display:flex;gap:10px;justify-content:space-between;align-items:center;
      padding:10px 12px;background:#161616;border-top:1px solid #222;
    }
    button{
      background:#232323;color:#eee;border:1px solid #3a3a3a;border-radius:12px;
      padding:10px 12px;font-size:14px;
    }
    button:active{transform:scale(0.98)}
    #log{
      font-size:12px;color:#aaa;max-width:60vw;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
    }
  </style>
</head>
<body>
<div id="wrap">
  <div id="hud">
    <div id="toprow">
      <div class="pill">æ®‹ã‚Š <span id="timeLeft">45.0</span>s</div>
      <div class="pill">ã‚¹ã‚³ã‚¢ <span id="score">0</span> / ã‚³ãƒ³ãƒœ Ã—<span id="combo">1</span></div>
      <div class="pill" id="phrase">æ¬¡ï¼</div>
    </div>

    <!-- ä¸Šæ®µï¼šæŒ‡ç¤º -->
    <div id="orderInstructions"></div>
    <!-- ä¸‹æ®µï¼šå®¢ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆåˆ—ä½ç½®ã¯ä¸Šæ®µã¨åŒã˜ï¼‰ -->
    <div id="customerIcons"></div>

    <div id="tip">æ“ä½œï¼šå³ã‹ã‚‰å‡ºã‚‹éººã‚’ãƒ‰ãƒ©ãƒƒã‚°â†’ä¸‹ã®ã€Œã¦ã¼ã€ã«å…¥ã‚Œã‚‹ï¼ã¦ã¼å†…ã®éººã‚’ã‚¿ãƒƒãƒ—â†’ä¸Šæ–¹å‘ã¸æä¾›</div>
  </div>

  <div id="canvasWrap">
    <canvas id="c" width="420" height="720"></canvas>
  </div>

  <div id="footer">
    <button id="adBtn">ã‚¢ãƒ«ãƒã‚¤ãƒˆå¬å–šï¼ˆä»®ï¼‰</button>
    <div id="log">ãƒ­ã‚°ï¼šâ€”</div>
    <button id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const ui = {
    timeLeft: document.getElementById('timeLeft'),
    score: document.getElementById('score'),
    combo: document.getElementById('combo'),
    orderInstructions: document.getElementById('orderInstructions'),
    customerIcons: document.getElementById('customerIcons'),
    phrase: document.getElementById('phrase'),
    log: document.getElementById('log'),
    resetBtn: document.getElementById('resetBtn'),
    adBtn: document.getElementById('adBtn'),
  };

  function fitCanvas() {
    const rect = canvas.getBoundingClientRect();
    const cssW = rect.width;
    const targetW = Math.min(520, Math.max(340, Math.floor(cssW)));
    const targetH = Math.floor(targetW * (720/420));
    canvas.width = targetW;
    canvas.height = targetH;
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // ========= Game constants =========
  const GAME_TIME = 45.0;
  const laneCount = 2; // ä»®ç‰ˆå›ºå®šï¼ˆ2ãƒ¬ãƒ¼ãƒ³ï¼‰

  const HARD = [
    { key:'ã‹ãŸ',   a:0.0, b:1.2, justA:0.4, justB:0.8, color:'#c9b458' },
    { key:'ãµã¤ã†', a:1.2, b:2.4, justA:1.6, justB:2.0, color:'#70c1b3' },
    { key:'ã‚„ã‚',   a:2.4, b:3.6, justA:2.8, justB:3.2, color:'#a0c4ff' },
  ];
  const OVERCOOK = 3.6;
  const OVERCOOK_COLOR = '#ffadad';

  const NOODLE_SPAWN_MIN = 0.85;
  const NOODLE_SPAWN_MAX = 1.25;

  // å®¢ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆä»®ï¼‰
  const CUSTOMER_EMOJIS = ['ğŸ™‚','ğŸ˜','ğŸ˜„','ğŸ§¢','ğŸ‘“','ğŸ§‘'];
  const CUSTOMER_NAMES  = ['ãƒ¢ãƒ–å®¢A','ãƒ¢ãƒ–å®¢B','ãƒ¢ãƒ–å®¢C','å¸¸é€£','ä»•äº‹å¸°ã‚Š','å­¦ç”Ÿ'];

  // ========= State =========
  let t = 0;
  let last = performance.now();
  let timeLeft = GAME_TIME;
  let score = 0;
  let combo = 1;
  let comboStreak = 0;

  let lanes = [];
  let flying = [];      // æä¾›ã‚¢ãƒ‹ãƒ¡
  let activeNoodle = null;  // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®éºº
  let spawnTimer = rand(NOODLE_SPAWN_MIN, NOODLE_SPAWN_MAX);

  let pointer = { id:null, x:0, y:0, down:false };
  let phraseTimer = 0;

  function rand(a,b){ return a + Math.random()*(b-a); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

  function setPhrase(text, ms=900){
    ui.phrase.textContent = text;
    phraseTimer = ms/1000;
  }
  function log(msg){
    ui.log.textContent = 'ãƒ­ã‚°ï¼š' + msg;
  }
  function syncHUD(){
    ui.timeLeft.textContent = timeLeft.toFixed(1);
    ui.score.textContent = score.toString();
    ui.combo.textContent = combo.toString();
  }

  function hardnessByTime(sec){
    if (sec >= OVERCOOK) return { key:'ã®ã³', just:false, ok:false, color:OVERCOOK_COLOR };
    const h = HARD.find(h => sec >= h.a && sec < h.b) || HARD[HARD.length-1];
    const just = sec >= h.justA && sec <= h.justB;
    return { key:h.key, just, ok:true, color:h.color };
  }

  function randomCustomer(){
    const i = Math.floor(Math.random() * CUSTOMER_EMOJIS.length);
    return { emoji: CUSTOMER_EMOJIS[i], name: CUSTOMER_NAMES[i] };
  }

  function newOrder(){
    const target = HARD[Math.floor(Math.random()*HARD.length)].key;
    return {
      target,
      patience: rand(6.0, 10.0),
      special: 'é€šå¸¸',
      customer: randomCustomer(),
    };
  }

  function initLanes(){
    lanes = [];
    for (let i=0;i<laneCount;i++){
      lanes.push({
        noodlesInBasket: [],
        order: newOrder(),
        auto: { enabled:false, timeLeft:0, usesLeft:0 },
      });
    }
    updateTopRows();
  }

  // â˜…ä¸Šæ®µï¼ˆæŒ‡ç¤ºï¼‰ï¼‹ä¸‹æ®µï¼ˆå®¢ã‚¢ã‚¤ã‚³ãƒ³ï¼‰ã‚’åŒã˜åˆ—ã§æç”»
  function updateTopRows(){
    ui.orderInstructions.innerHTML = '';
    ui.customerIcons.innerHTML = '';
    ui.orderInstructions.style.gridTemplateColumns = `repeat(${laneCount}, 1fr)`;
    ui.customerIcons.style.gridTemplateColumns = `repeat(${laneCount}, 1fr)`;

    for (let i=0;i<laneCount;i++){
      const lane = lanes[i];
      const o = lane.order;

      // ä¸Šæ®µï¼šæŒ‡ç¤º
      const oc = document.createElement('div');
      oc.className = 'orderCard';
      oc.innerHTML = `
        <div class="orderTitle">
          <span>ãƒ¬ãƒ¼ãƒ³${i+1} æŒ‡ç¤º</span>
          <span class="badge">${o.special}</span>
        </div>
        <div class="orderHard">ç¡¬ã•ï¼š${o.target}</div>
        <div class="orderMeta">å¾…ã¡ï¼š${o.patience.toFixed(1)}s</div>
      `;
      ui.orderInstructions.appendChild(oc);

      // ä¸‹æ®µï¼šå®¢ã‚¢ã‚¤ã‚³ãƒ³
      const cc = document.createElement('div');
      cc.className = 'customerCard';
      cc.innerHTML = `
        <div class="customerAvatar">${o.customer.emoji}</div>
        <div class="customerText">
          <div class="customerName">${o.customer.name}</div>
          <div>æ›¿ç‰å¾…ã¡</div>
        </div>
      `;
      ui.customerIcons.appendChild(cc);
    }
  }

  function completeOrder(laneIndex){
    lanes[laneIndex].order = newOrder();
    updateTopRows();
  }

  // ========= Layout =========
  // å®¢ã‚¢ã‚¤ã‚³ãƒ³ã¯ã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã«ç½®ã‹ãªã„ã€‚ä¸­å¤®ã‚’é£›è¡Œç©ºé–“ã«ã™ã‚‹ã€‚
  // å³å´ã«ã¯ç¡¬ã•å‡¡ä¾‹ãƒ‘ãƒãƒ«ã‚’é…ç½®ã€‚
  function layout(){
    const W = canvas.width, H = canvas.height;

    // å³å´å‡¡ä¾‹ã‚¹ãƒšãƒ¼ã‚¹
    const rightPanelW = Math.max(92, Math.floor(W * 0.23));
    const playW = W - rightPanelW - 8; // ä¸­å¤®ã€œå·¦ãŒãƒ—ãƒ¬ã‚¤ç©ºé–“
    const rightPanelX = W - rightPanelW;

    // ä¸‹éƒ¨ã¦ã¼ã‚¾ãƒ¼ãƒ³
    const basketZoneH = H * 0.33;
    const basketTop = H - basketZoneH;

    // éººã®æ’å‡ºå£ï¼ˆå³ç«¯ã ãŒã€å‡¡ä¾‹ãƒ‘ãƒãƒ«ã‚ˆã‚Šå·¦å´ï¼‰
    const spout = {
      x: playW - 12,
      y: basketTop - 90,
      r: 16
    };

    const pad = 12;
    const laneW = (playW - pad * (laneCount + 1)) / laneCount;
    const baskets = [];
    for (let i=0;i<laneCount;i++){
      const x = pad + i*(laneW+pad);
      const y = basketTop + 18;
      baskets.push({
        x, y, w: laneW, h: basketZoneH - 36,
        laneIndex: i,
        cx: x + laneW/2,
        cy: y + (basketZoneH - 36) * 0.62,
      });
    }

    // æä¾›å…ˆï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹å†…ã®ä¸Šéƒ¨ãƒ»è¦‹ãˆãªã„ç›®æ¨™ç‚¹ï¼‰ã€‚å®¢ã‚¢ã‚¤ã‚³ãƒ³ã¯HUDã«ã‚ã‚‹ã®ã§æç”»ã—ãªã„
    const targets = baskets.map((b, i) => ({
      x: b.cx,
      y: Math.max(56, basketTop - 190), // ã‹ãªã‚Šä¸Šã«
      r: 1
    }));

    // å‡¡ä¾‹ãƒ‘ãƒãƒ«
    const legend = {
      x: rightPanelX + 6,
      y: 10,
      w: rightPanelW - 12,
      h: Math.min(H * 0.48, 220)
    };

    return { W,H, playW, basketTop, spout, baskets, targets, legend, rightPanelX, rightPanelW };
  }

  function reset(){
    t = 0;
    timeLeft = GAME_TIME;
    score = 0;
    combo = 1;
    comboStreak = 0;
    flying = [];
    activeNoodle = null;
    spawnTimer = rand(NOODLE_SPAWN_MIN, NOODLE_SPAWN_MAX);
    setPhrase('æ¬¡ï¼', 700);
    initLanes();
    syncHUD();
    log('ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
  }

  // ========= Input =========
  function canvasPointFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top)  * (canvas.height / rect.height);
    return {x,y};
  }

  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    pointer.id = e.pointerId;
    pointer.down = true;
    const p = canvasPointFromEvent(e);
    pointer.x = p.x; pointer.y = p.y;

    const geo = layout();

    // ã¦ã¼å†…ã®éººã‚¿ãƒƒãƒ—ã§æä¾›
    for (let i=0;i<laneCount;i++){
      const arr = lanes[i].noodlesInBasket;
      for (let j=arr.length-1;j>=0;j--){
        const n = arr[j];
        if (dist2(p.x,p.y,n.x,n.y) <= n.r*n.r){
          fireFromBasket(i, j, geo);
          return;
        }
      }
    }

    // å‡ºç¾éººã‚’æ´ã‚€
    if (activeNoodle && dist2(p.x,p.y,activeNoodle.x,activeNoodle.y) <= activeNoodle.r*activeNoodle.r){
      activeNoodle.dragging = true;
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!pointer.down || e.pointerId !== pointer.id) return;
    const p = canvasPointFromEvent(e);
    pointer.x = p.x; pointer.y = p.y;

    if (activeNoodle && activeNoodle.dragging){
      activeNoodle.x = p.x;
      activeNoodle.y = p.y;
    }
  });

  canvas.addEventListener('pointerup', (e) => {
    if (e.pointerId !== pointer.id) return;
    pointer.down = false;
    const p = canvasPointFromEvent(e);
    pointer.x = p.x; pointer.y = p.y;

    if (activeNoodle && activeNoodle.dragging){
      activeNoodle.dragging = false;
      const geo = layout();
      const b = geo.baskets.find(b => p.x>=b.x && p.x<=b.x+b.w && p.y>=b.y && p.y<=b.y+b.h);
      if (b){
        lanes[b.laneIndex].noodlesInBasket.push({
          cook: 0,
          x: b.cx + rand(-18,18),
          y: b.cy + rand(-18,18),
          r: 14,
          lane: b.laneIndex
        });
        activeNoodle = null;
        log(`ãƒ¬ãƒ¼ãƒ³${b.laneIndex+1}ã«æŠ•å…¥`);
        setPhrase('æ¬¡ï¼', 550);
      }
    }
  });

  // ========= Spawn / Score =========
  function spawnNoodle(geo){
    activeNoodle = {
      x: geo.spout.x - 26,
      y: geo.spout.y,
      r: 16,
      vx: -34,
      vy: 0,
      dragging: false,
      born: t,
    };
  }

  function award(points, isJust){
    score += points * combo;
    comboStreak++;
    if (comboStreak % 5 === 0) combo = Math.min(9, combo + 1);
    if (isJust) setPhrase('ç¡¬ã•ãƒ¨ã‚·ï¼', 900);
    syncHUD();
  }

  function penalty(points){
    score = Math.max(0, score - points);
    combo = 1;
    comboStreak = 0;
    syncHUD();
  }

  function fireFromBasket(laneIndex, noodleIndex, geo){
    const lane = lanes[laneIndex];
    const n = lane.noodlesInBasket.splice(noodleIndex, 1)[0];
    const h = hardnessByTime(n.cook);
    const target = geo.targets[laneIndex];

    // é£›è¡Œã‚¢ãƒ‹ãƒ¡ï¼ˆå®¢ã‚¢ã‚¤ã‚³ãƒ³ã¯HUDãªã®ã§ã€ä¸Šæ–¹å‘ã¸é£›ã¶ã ã‘ï¼‰
    const dx = target.x - n.x;
    const dy = target.y - n.y;
    const len = Math.max(1, Math.hypot(dx,dy));
    const speed = 600;
    flying.push({
      x:n.x, y:n.y, r:12,
      vx: dx/len*speed,
      vy: dy/len*speed,
      laneIndex,
      ttl: 0.55
    });

    const order = lane.order;
    if (!h.ok){
      log(`ã®ã³ï¼ˆãƒ¬ãƒ¼ãƒ³${laneIndex+1}ï¼‰`);
      setPhrase('ç„¦ã‚‹ã¨â€œã®ã³â€ã‚‹', 1200);
      penalty(15);
      order.patience = Math.max(0, order.patience - 1.5);
      updateTopRows();
      return;
    }

    if (h.key === order.target){
      if (h.just){
        log(`ã‚¸ãƒ£ã‚¹ãƒˆæˆåŠŸï¼ ãƒ¬ãƒ¼ãƒ³${laneIndex+1}`);
        award(20, true);
      } else {
        log(`æˆåŠŸ ãƒ¬ãƒ¼ãƒ³${laneIndex+1}`);
        award(10, false);
      }
      completeOrder(laneIndex);
    } else {
      log(`ç¡¬ã•ãƒŸã‚¹ï¼ˆ${h.key}â†’æ³¨æ–‡:${order.target}ï¼‰`);
      penalty(10);
      order.patience = Math.max(0, order.patience - 2.0);
      updateTopRows();
    }
  }

  // ========= Buttons =========
  ui.adBtn.addEventListener('click', () => {
    // ä»®ï¼šãƒ¬ãƒ¼ãƒ³1ã‚’è£œåŠ©
    const laneIndex = 0;
    lanes[laneIndex].auto.enabled = true;
    lanes[laneIndex].auto.timeLeft = 12.0;
    lanes[laneIndex].auto.usesLeft = 6;
    log('ã‚¢ãƒ«ãƒã‚¤ãƒˆï¼ˆä»®ï¼‰: ãƒ¬ãƒ¼ãƒ³1ã‚’12ç§’è£œåŠ©');
  });

  ui.resetBtn.addEventListener('click', reset);

  // ========= Main loop =========
  function step(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    t += dt;

    if (phraseTimer > 0){
      phraseTimer -= dt;
      if (phraseTimer <= 0) ui.phrase.textContent = 'æ¬¡ï¼';
    }

    if (timeLeft > 0){
      timeLeft = Math.max(0, timeLeft - dt);
    }
    syncHUD();

    const geo = layout();

    // éººã®è‡ªå‹•æ’å‡º
    spawnTimer -= dt;
    if (timeLeft > 0 && spawnTimer <= 0){
      if (!activeNoodle) spawnNoodle(geo);
      spawnTimer = rand(NOODLE_SPAWN_MIN, NOODLE_SPAWN_MAX);
    }

    // å‡ºç¾éººï¼ˆæœªãƒ‰ãƒ©ãƒƒã‚°ï¼‰ã®æ¼‚ã„
    if (activeNoodle && !activeNoodle.dragging){
      activeNoodle.x += activeNoodle.vx * dt;
      activeNoodle.x = clamp(activeNoodle.x, Math.max(40, geo.playW - 150), geo.playW - 26);
      activeNoodle.y = clamp(activeNoodle.y + Math.sin(t*2.1)*8*dt, 14, geo.basketTop - 14);
    }

    // ãƒ¬ãƒ¼ãƒ³æ›´æ–°
    for (let i=0;i<laneCount;i++){
      const lane = lanes[i];

      // å®¢å¾…ã¡æ™‚é–“
      if (timeLeft > 0){
        lane.order.patience = Math.max(0, lane.order.patience - dt);
        if (lane.order.patience === 0){
          penalty(5);
          log(`ãƒ¬ãƒ¼ãƒ³${i+1} å®¢ãŒå¸°ã£ãŸâ€¦ï¼ˆ-5ï¼‰`);
          lane.order = newOrder();
          updateTopRows();
        }
      }

      // èŒ¹ã§æ™‚é–“é€²è¡Œ
      for (const n of lane.noodlesInBasket){
        n.cook += dt;
      }

      // ã‚¢ãƒ«ãƒã‚¤ãƒˆä»®
      if (lane.auto.enabled && timeLeft > 0){
        lane.auto.timeLeft = Math.max(0, lane.auto.timeLeft - dt);
        if (lane.auto.timeLeft === 0) lane.auto.enabled = false;

        if (lane.auto.usesLeft > 0 && lane.noodlesInBasket.length > 0){
          let idx = 0;
          for (let j=1;j<lane.noodlesInBasket.length;j++){
            if (lane.noodlesInBasket[j].cook > lane.noodlesInBasket[idx].cook) idx = j;
          }
          if (Math.random() < dt * 1.3){
            fireFromBasket(i, idx, geo);
            lane.auto.usesLeft--;
          }
        }
      }
    }

    // é£›è¡Œéºº
    for (let i=flying.length-1;i>=0;i--){
      const f = flying[i];
      f.x += f.vx * dt;
      f.y += f.vy * dt;
      f.ttl -= dt;
      if (f.ttl <= 0 || f.y < -50 || f.x < -50 || f.x > canvas.width + 50){
        flying.splice(i,1);
      }
    }

    draw(geo);
    requestAnimationFrame(step);
  }

  // ========= Draw =========
  function draw(geo){
    const {W,H,playW,basketTop,spout,baskets,legend,rightPanelX,rightPanelW} = geo;
    ctx.clearRect(0,0,W,H);

    // å³å´å‡¡ä¾‹ãƒ‘ãƒãƒ«èƒŒæ™¯ï¼ˆç¡¬ã•è‰²ã®æ˜ç¤ºï¼‰
    ctx.fillStyle = '#141414';
    ctx.fillRect(rightPanelX, 0, rightPanelW, H);
    ctx.strokeStyle = '#262626';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(rightPanelX + 0.5, 0);
    ctx.lineTo(rightPanelX + 0.5, H);
    ctx.stroke();

    // ä¸­å¤®é£›è¡Œã‚¹ãƒšãƒ¼ã‚¹ï¼ˆå®¢ã‚¢ã‚¤ã‚³ãƒ³ãªã—ï¼‰
    ctx.fillStyle = '#0f0f0f';
    ctx.fillRect(0, basketTop - 2, playW, 2);

    // æ’å‡ºå£
    ctx.fillStyle = '#2a2a2a';
    ctx.beginPath();
    ctx.arc(spout.x, spout.y, spout.r, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#3a3a3a';
    ctx.fillRect(spout.x-26, spout.y-10, 26, 20);

    // ã¦ã¼ãƒ¬ãƒ¼ãƒ³
    for (const b of baskets){
      ctx.fillStyle = '#141414';
      ctx.fillRect(b.x, b.y, b.w, b.h);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.strokeRect(b.x, b.y, b.w, b.h);

      // ãƒ¬ãƒ¼ãƒ³å
      ctx.fillStyle = '#888';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText(`ã¦ã¼${b.laneIndex+1}`, b.x+8, b.y+16);

      // ãƒã‚¤ãƒˆè¡¨ç¤º
      const lane = lanes[b.laneIndex];
      if (lane.auto.enabled){
        ctx.fillStyle = '#9bd';
        ctx.textAlign = 'right';
        ctx.fillText(`ãƒã‚¤ãƒˆ ${lane.auto.timeLeft.toFixed(0)}s`, b.x+b.w-8, b.y+16);
      }

      // ã¦ã¼å†…ã®éºº
      for (const n of lane.noodlesInBasket){
        const h = hardnessByTime(n.cook);

        ctx.fillStyle = h.color;
        ctx.beginPath();
        ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
        ctx.fill();

        if (h.just){
          ctx.strokeStyle = '#fff';
          ctx.globalAlpha = 0.35;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(n.x, n.y, n.r+2, 0, Math.PI*2);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // ã¦ã¼ä¸‹éƒ¨ã«ç¾åœ¨æ³¨æ–‡ï¼ˆç°¡æ˜“ï¼‰
      const order = lane.order;
      ctx.fillStyle = '#ddd';
      ctx.font = '13px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`æ³¨æ–‡:${order.target}`, b.cx, b.y + b.h - 12);
    }

    // å‡ºç¾ä¸­ã®éºº
    if (activeNoodle){
      ctx.fillStyle = '#f4f4f4';
      ctx.beginPath();
      ctx.arc(activeNoodle.x, activeNoodle.y, activeNoodle.r, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = '#aaa';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('éºº', activeNoodle.x + 18, activeNoodle.y + 4);
    }

    // é£›è¡Œéººï¼ˆå®¢ã‚¢ã‚¤ã‚³ãƒ³ã¯æã‹ãªã„ï¼‰
    for (const f of flying){
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
      ctx.fill();
    }

    // â˜…ç¡¬ã•å‡¡ä¾‹ï¼ˆå³å´ç©ºã‚¹ãƒšãƒ¼ã‚¹ï¼‰
    drawHardnessLegend(legend);

    // æ™‚é–“çµ‚äº†
    if (timeLeft <= 0){
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff';
      ctx.font = '24px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('æ™‚é–“çµ‚äº†', W/2, H/2 - 14);
      ctx.font = '16px sans-serif';
      ctx.fillText(`ã‚¹ã‚³ã‚¢ ${score}`, W/2, H/2 + 16);
      ctx.font = '13px sans-serif';
      ctx.fillStyle = '#ccc';
      ctx.fillText('ä¸‹ã®ã€Œãƒªã‚»ãƒƒãƒˆã€ã§å†é–‹', W/2, H/2 + 40);
    }
  }

  function drawHardnessLegend(legend){
    const x = legend.x, y = legend.y, w = legend.w, h = legend.h;
    ctx.fillStyle = '#191919';
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = '#2f2f2f';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, w, h);

    ctx.fillStyle = '#eee';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('ç¡¬ã•è‰²', x + 8, y + 16);

    let cy = y + 34;
    const rowH = 22;

    const items = [
      {label:'ã‹ãŸ', color:HARD[0].color},
      {label:'ãµã¤ã†', color:HARD[1].color},
      {label:'ã‚„ã‚', color:HARD[2].color},
      {label:'ã®ã³', color:OVERCOOK_COLOR},
    ];

    for (const item of items){
      ctx.fillStyle = item.color;
      ctx.fillRect(x + 8, cy - 10, 16, 10);
      ctx.strokeStyle = '#444';
      ctx.strokeRect(x + 8, cy - 10, 16, 10);

      ctx.fillStyle = '#d8d8d8';
      ctx.font = '12px sans-serif';
      ctx.fillText(item.label, x + 30, cy - 1);
      cy += rowH;
    }

    cy += 4;
    ctx.fillStyle = '#eee';
    ctx.fillText('ã‚¸ãƒ£ã‚¹ãƒˆ', x + 8, cy + 2);

    // ã‚¸ãƒ£ã‚¹ãƒˆè¦‹æœ¬
    const px = x + 18;
    const py = cy + 24;
    ctx.fillStyle = HARD[1].color;
    ctx.beginPath();
    ctx.arc(px, py, 7, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.globalAlpha = 0.35;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(px, py, 10, 0, Math.PI*2);
    ctx.stroke();
    ctx.globalAlpha = 1;

    ctx.fillStyle = '#cfcfcf';
    ctx.font = '11px sans-serif';
    ctx.fillText('ç™½ã„è¼ª = ã‚¸ãƒ£ã‚¹ãƒˆ', x + 34, py + 4);

    // è£œè¶³
    ctx.fillStyle = '#9aa';
    ctx.font = '10px sans-serif';
    ctx.fillText('â€»åšå¤šç¡¬ã•ã¯å¾Œã§è¿½åŠ äºˆå®š', x + 8, Math.min(y + h - 8, py + 28));
  }

  // ========= Start =========
  reset();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
