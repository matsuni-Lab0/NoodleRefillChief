<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Tebo Shop Prototype - Layout Match (Master Sketch)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
    }
    #app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      box-sizing: border-box;
      gap: 8px;
    }
    #topbar {
      width: min(980px, 96vw);
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
    }
    .pill {
      background: #1c1c1c;
      border: 1px solid #333;
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 14px;
      white-space: nowrap;
    }
    #boardWrap {
      width: min(980px, 96vw);
      display: flex;
      justify-content: center;
    }
    canvas {
      width: 100%;
      height: auto;
      max-width: 980px;
      background: #0e0e0e;
      border: 1px solid #2a2a2a;
      border-radius: 12px;
      touch-action: none;
      display: block;
    }
    #footer {
      width: min(980px, 96vw);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      background: #222;
      color: #eee;
      border: 1px solid #3a3a3a;
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
    }
    #log {
      color: #aaa;
      font-size: 12px;
      flex: 1;
      min-width: 220px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      text-align: center;
    }
  </style>
</head>
<body>
<div id="app">
  <div id="topbar">
    <div class="pill">æ®‹ã‚Š <span id="timeLeft">45.0</span>s</div>
    <div class="pill">ã‚¹ã‚³ã‚¢ <span id="score">0</span></div>
    <div class="pill">ã‚³ãƒ³ãƒœ Ã—<span id="combo">1</span></div>
    <div class="pill" id="phrase">æ¬¡ï¼</div>
  </div>

  <div id="boardWrap">
    <canvas id="game" width="980" height="720"></canvas>
  </div>

  <div id="footer">
    <button id="adBtn">ã‚¢ãƒ«ãƒã‚¤ãƒˆå¬å–šï¼ˆä»®ï¼‰</button>
    <div id="log">ãƒ­ã‚°ï¼šâ€”</div>
    <button id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const ui = {
    timeLeft: document.getElementById('timeLeft'),
    score: document.getElementById('score'),
    combo: document.getElementById('combo'),
    phrase: document.getElementById('phrase'),
    log: document.getElementById('log'),
    resetBtn: document.getElementById('resetBtn'),
    adBtn: document.getElementById('adBtn'),
  };

  // ========= åŸºæœ¬è¨­å®š =========
  const GAME_TIME = 45;
  const LANE_COUNT = 4; // ãƒ©ãƒ•ã«åˆã‚ã›ã¦4ãƒ¬ãƒ¼ãƒ³è¡¨ç¤º
  const NOODLE_SPAWN_MIN = 0.75;
  const NOODLE_SPAWN_MAX = 1.15;
  const OVERCOOK = 3.6;

  const HARDNESS_TABLE = [
    { key:'ã‹ãŸ',   a:0.0, b:1.2, justA:0.4, justB:0.8, color:'#d6b85c' },
    { key:'ãµã¤ã†', a:1.2, b:2.4, justA:1.6, justB:2.0, color:'#65c8b7' },
    { key:'ã‚„ã‚',   a:2.4, b:3.6, justA:2.8, justB:3.2, color:'#8fb8ff' },
  ];
  const COLOR_NOBI = '#ff9d9d';

  const CUSTOMER_ICONS = ['ğŸ™‚','ğŸ˜','ğŸ˜‘','ğŸ˜„','ğŸ§¢','ğŸ‘“','ğŸ§‘','ğŸ‘¨'];
  const CUSTOMER_NAMES = ['å®¢A','å®¢B','å®¢C','å¸¸é€£','ä¼šç¤¾å“¡','å­¦ç”Ÿ','ãƒ¢ãƒ–å®¢','ãŠå®¢ã•ã‚“'];

  // ========= çŠ¶æ…‹ =========
  let last = performance.now();
  let t = 0;
  let timeLeft = GAME_TIME;
  let score = 0;
  let combo = 1;
  let comboStreak = 0;
  let phraseTimer = 0;
  let spawnTimer = rnd(NOODLE_SPAWN_MIN, NOODLE_SPAWN_MAX);

  let lanes = [];
  let activeNoodle = null; // å³å´ã‹ã‚‰å‡ºã¦ã€ãƒ‰ãƒ©ãƒƒã‚°æŠ•å…¥ã™ã‚‹éºº
  let flying = [];         // æä¾›æ™‚ã«é£›ã¶éºº
  let pointer = { down:false, id:null, x:0, y:0 };

  // ======= ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆæ‰‹æããƒ©ãƒ•å¯„ã›ï¼‰ =======
  function getLayout() {
    const W = canvas.width;
    const H = canvas.height;

    // å³å´ï¼šå‡¡ä¾‹ã‚¨ãƒªã‚¢ï¼ˆå›ºå®šï¼‰
    const legendW = 150;
    const boardPad = 18;
    const playX = boardPad;
    const playY = boardPad;
    const playW = W - legendW - boardPad*2;
    const playH = H - boardPad*2;

    // ä¸Šæ®µï¼šæŒ‡ç¤ºè¡Œ + å®¢ã‚¢ã‚¤ã‚³ãƒ³è¡Œ
    const headerLineY = playY + 28;     // ã€Œã‹ãŸ/ã‚„ã‚/æ™®é€šã€
    const customerRowY = playY + 78;    // é¡”ã‚¢ã‚¤ã‚³ãƒ³ã®ä¸­å¿ƒ

    // ä¸‹æ®µï¼šã¦ã¼è¡Œ
    const basketH = 110;
    const basketY = playY + playH - basketH - 6;

    // ç¸¦ãƒ¬ãƒ¼ãƒ³å¹…
    const laneGap = 14;
    const laneW = (playW - laneGap*(LANE_COUNT-1)) / LANE_COUNT;

    const lanesGeo = [];
    for (let i=0;i<LANE_COUNT;i++){
      const x = playX + i*(laneW + laneGap);
      lanesGeo.push({
        i,
        x,
        w: laneW,
        centerX: x + laneW/2,
        topY: customerRowY + 18,   // é¡”ã®å°‘ã—ä¸‹ã‹ã‚‰ãƒ¬ãƒ¼ãƒ³é–‹å§‹
        bottomY: basketY - 12,
        basket: {
          x: x + 8,
          y: basketY,
          w: laneW - 16,
          h: basketH,
          cx: x + laneW/2,
          cy: basketY + basketH*0.48
        },
        targetY: customerRowY + 4, // æä¾›ã‚¢ãƒ‹ãƒ¡ã®åˆ°é”ç‚¹ï¼ˆé¡”ä»˜è¿‘ï¼‰
      });
    }

    // å³ä¸­æ®µã®æ’å‡ºå£ï¼ˆãƒ©ãƒ•ã®ã€Œã‚ã‚“å‡ºã‚‹ã€ä½ç½®ï¼‰
    const spout = {
      x: playX + playW + 8,      // ãƒ—ãƒ¬ã‚¤ç©ºé–“ã®å³ç«¯ä»˜è¿‘
      y: playY + playH * 0.54,
      w: 54,
      h: 16
    };

    const legend = {
      x: W - legendW - boardPad,
      y: playY + 10,
      w: legendW,
      h: 150
    };

    return {
      W,H, boardPad, playX, playY, playW, playH,
      headerLineY, customerRowY, basketY,
      lanesGeo, spout, legend
    };
  }

  // ========= åˆæœŸåŒ– =========
  function rnd(a,b){ return a + Math.random()*(b-a); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function d2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

  function randomCustomer() {
    const idx = Math.floor(Math.random()*CUSTOMER_ICONS.length);
    return { icon: CUSTOMER_ICONS[idx], name: CUSTOMER_NAMES[idx] };
  }

  function newOrder() {
    const hard = HARDNESS_TABLE[Math.floor(Math.random()*HARDNESS_TABLE.length)];
    return {
      target: hard.key,
      patience: rnd(7, 11),
      customer: randomCustomer(),
      special: 'é€šå¸¸'
    };
  }

  function initLanes() {
    lanes = [];
    for (let i=0;i<LANE_COUNT;i++){
      lanes.push({
        order: newOrder(),
        noodlesInBasket: [], // { cook, x, y, r }
        auto: { enabled:false, timeLeft:0, usesLeft:0 }
      });
    }
  }

  function resetGame() {
    t = 0;
    timeLeft = GAME_TIME;
    score = 0;
    combo = 1;
    comboStreak = 0;
    phraseTimer = 0;
    spawnTimer = rnd(NOODLE_SPAWN_MIN, NOODLE_SPAWN_MAX);
    activeNoodle = null;
    flying = [];
    initLanes();
    setPhrase('æ¬¡ï¼', 700);
    log('ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
    syncHud();
  }

  function syncHud() {
    ui.timeLeft.textContent = timeLeft.toFixed(1);
    ui.score.textContent = String(score);
    ui.combo.textContent = String(combo);
  }

  function log(msg) {
    ui.log.textContent = 'ãƒ­ã‚°ï¼š' + msg;
  }

  function setPhrase(text, ms=900) {
    ui.phrase.textContent = text;
    phraseTimer = ms/1000;
  }

  function hardnessByTime(sec) {
    if (sec >= OVERCOOK) return { key:'ã®ã³', ok:false, just:false, color:COLOR_NOBI };
    const h = HARDNESS_TABLE.find(x => sec >= x.a && sec < x.b) || HARDNESS_TABLE[0];
    const just = sec >= h.justA && sec <= h.justB;
    return { key:h.key, ok:true, just, color:h.color };
  }

  // ========= å…¥åŠ› =========
  function canvasPoint(e){
    const r = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - r.left) * (canvas.width / r.width),
      y: (e.clientY - r.top) * (canvas.height / r.height)
    };
  }

  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    pointer.down = true;
    pointer.id = e.pointerId;
    const p = canvasPoint(e);
    pointer.x = p.x; pointer.y = p.y;

    const geo = getLayout();

    // 1) ã¦ã¼å†…éººã‚¿ãƒƒãƒ—ã§æä¾›
    for (let i=0;i<LANE_COUNT;i++){
      const arr = lanes[i].noodlesInBasket;
      for (let j=arr.length-1;j>=0;j--){
        const n = arr[j];
        if (d2(p.x,p.y,n.x,n.y) <= n.r*n.r){
          fireNoodleFromBasket(i, j, geo);
          return;
        }
      }
    }

    // 2) æ’å‡ºéººã‚’æ´ã‚€
    if (activeNoodle && d2(p.x,p.y,activeNoodle.x,activeNoodle.y) <= activeNoodle.r*activeNoodle.r) {
      activeNoodle.dragging = true;
      return;
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!pointer.down || e.pointerId !== pointer.id) return;
    const p = canvasPoint(e);
    pointer.x = p.x; pointer.y = p.y;
    if (activeNoodle && activeNoodle.dragging) {
      activeNoodle.x = p.x;
      activeNoodle.y = p.y;
    }
  });

  canvas.addEventListener('pointerup', (e) => {
    if (e.pointerId !== pointer.id) return;
    pointer.down = false;

    const p = canvasPoint(e);
    pointer.x = p.x; pointer.y = p.y;

    if (activeNoodle && activeNoodle.dragging){
      activeNoodle.dragging = false;
      const geo = getLayout();

      // ã©ã®ã¦ã¼ã«å…¥ã£ãŸã‹åˆ¤å®š
      for (let i=0;i<LANE_COUNT;i++){
        const b = geo.lanesGeo[i].basket;
        if (p.x >= b.x && p.x <= b.x+b.w && p.y >= b.y && p.y <= b.y+b.h){
          lanes[i].noodlesInBasket.push({
            cook: 0,
            x: b.cx + rnd(-16, 16),
            y: b.cy + rnd(-14, 14),
            r: 12
          });
          activeNoodle = null;
          log(`ã¦ã¼${i+1}ã«æŠ•å…¥`);
          setPhrase('æ¬¡ï¼', 500);
          return;
        }
      }
    }
  });

  // ========= ã‚²ãƒ¼ãƒ å‡¦ç† =========
  function spawnNoodle(geo){
    // ãƒ©ãƒ•ã«åˆã‚ã›ã¦å³ä¸­æ®µæ’å‡ºå£ã‹ã‚‰å‡ºã™
    activeNoodle = {
      x: geo.spout.x + geo.spout.w * 0.5,
      y: geo.spout.y + geo.spout.h * 0.5,
      r: 15,
      dragging: false,
      vx: -24
    };
  }

  function award(base, isJust){
    score += base * combo;
    comboStreak++;
    if (comboStreak % 5 === 0) combo = Math.min(9, combo + 1);
    if (isJust) setPhrase('ç¡¬ã•ãƒ¨ã‚·ï¼', 900);
    syncHud();
  }

  function penalty(p){
    score = Math.max(0, score - p);
    combo = 1;
    comboStreak = 0;
    syncHud();
  }

  function nextOrder(laneIndex){
    lanes[laneIndex].order = newOrder();
  }

  function fireNoodleFromBasket(laneIndex, noodleIndex, geo){
    const lane = lanes[laneIndex];
    const n = lane.noodlesInBasket.splice(noodleIndex, 1)[0];
    const h = hardnessByTime(n.cook);
    const order = lane.order;
    const laneGeo = geo.lanesGeo[laneIndex];

    // é£›è¡Œã‚¢ãƒ‹ãƒ¡ï¼ˆé¡”ä½ç½®ã¸ï¼‰
    const tx = laneGeo.centerX;
    const ty = laneGeo.targetY;
    const dx = tx - n.x;
    const dy = ty - n.y;
    const len = Math.max(1, Math.hypot(dx,dy));
    const speed = 700;

    flying.push({
      x:n.x, y:n.y, r:10,
      vx: dx/len*speed,
      vy: dy/len*speed,
      ttl: 0.45
    });

    if (!h.ok){
      log(`ã®ã³ï¼ˆã¦ã¼${laneIndex+1}ï¼‰`);
      setPhrase('ç„¦ã‚‹ã¨â€œã®ã³â€ã‚‹', 1200);
      penalty(15);
      order.patience = Math.max(0, order.patience - 1.5);
      return;
    }

    if (h.key === order.target){
      if (h.just){
        log(`ã‚¸ãƒ£ã‚¹ãƒˆæˆåŠŸï¼ˆã¦ã¼${laneIndex+1}ï¼‰`);
        award(20, true);
      } else {
        log(`æˆåŠŸï¼ˆã¦ã¼${laneIndex+1}ï¼‰`);
        award(10, false);
      }
      nextOrder(laneIndex);
    } else {
      log(`ç¡¬ã•ãƒŸã‚¹ï¼ˆ${h.key}â†’${order.target}ï¼‰`);
      penalty(10);
      order.patience = Math.max(0, order.patience - 2.0);
    }
  }

  function update(dt){
    const geo = getLayout();

    if (phraseTimer > 0){
      phraseTimer -= dt;
      if (phraseTimer <= 0) ui.phrase.textContent = 'æ¬¡ï¼';
    }

    if (timeLeft > 0){
      timeLeft = Math.max(0, timeLeft - dt);
    }
    syncHud();

    // éººæ’å‡º
    spawnTimer -= dt;
    if (timeLeft > 0 && spawnTimer <= 0){
      if (!activeNoodle) spawnNoodle(geo);
      spawnTimer = rnd(NOODLE_SPAWN_MIN, NOODLE_SPAWN_MAX);
    }

    // æœªãƒ‰ãƒ©ãƒƒã‚°éººã®å¾®ç§»å‹•ï¼ˆæ’å‡ºå£å‘¨è¾ºï¼‰
    if (activeNoodle && !activeNoodle.dragging){
      activeNoodle.x += activeNoodle.vx * dt;
      activeNoodle.x = clamp(activeNoodle.x, geo.spout.x - 80, geo.spout.x + 40);
      activeNoodle.y += Math.sin(t * 3.2) * 8 * dt;
      activeNoodle.y = clamp(activeNoodle.y, geo.spout.y - 20, geo.spout.y + 20);
    }

    // å„ãƒ¬ãƒ¼ãƒ³æ›´æ–°
    for (let i=0;i<LANE_COUNT;i++){
      const lane = lanes[i];
      const b = geo.lanesGeo[i].basket;

      // å¾…ã¡æ™‚é–“
      if (timeLeft > 0){
        lane.order.patience = Math.max(0, lane.order.patience - dt);
        if (lane.order.patience === 0){
          penalty(5);
          log(`ãƒ¬ãƒ¼ãƒ³${i+1} å®¢ãŒå¸°ã£ãŸâ€¦`);
          lane.order = newOrder();
        }
      }

      // èŒ¹ã§é€²è¡Œ
      for (const n of lane.noodlesInBasket){
        n.cook += dt;
        // è»½ã„æºã‚Œï¼ˆå›ºå®šä½ç½®æ„Ÿã‚’å¼±ã‚ã‚‹ï¼‰
        n.x = clamp(n.x + Math.sin((t+n.cook)*2.0) * 2.0 * dt, b.x+12, b.x+b.w-12);
        n.y = clamp(n.y + Math.cos((t+n.cook)*1.7) * 2.0 * dt, b.y+20, b.y+b.h-20);
      }

      // ã‚¢ãƒ«ãƒã‚¤ãƒˆï¼ˆä»®ï¼‰
      if (lane.auto.enabled && timeLeft > 0){
        lane.auto.timeLeft = Math.max(0, lane.auto.timeLeft - dt);
        if (lane.auto.timeLeft <= 0) lane.auto.enabled = false;

        if (lane.auto.usesLeft > 0 && lane.noodlesInBasket.length > 0){
          let idx = 0;
          for (let j=1;j<lane.noodlesInBasket.length;j++){
            if (lane.noodlesInBasket[j].cook > lane.noodlesInBasket[idx].cook) idx = j;
          }
          if (Math.random() < dt * 1.25){
            fireNoodleFromBasket(i, idx, geo);
            lane.auto.usesLeft--;
          }
        }
      }
    }

    // é£›è¡Œéºº
    for (let i=flying.length-1;i>=0;i--){
      const f = flying[i];
      f.x += f.vx * dt;
      f.y += f.vy * dt;
      f.ttl -= dt;
      if (f.ttl <= 0) flying.splice(i,1);
    }
  }

  // ========= æç”» =========
  function draw(){
    const geo = getLayout();
    const { W,H, playX, playY, playW, playH, lanesGeo, customerRowY, headerLineY, legend, spout } = geo;

    ctx.clearRect(0,0,W,H);

    // å¤–æ ï¼ˆãƒ©ãƒ•ã®å¤§ããªæ ï¼‰
    ctx.strokeStyle = '#3a3a3a';
    ctx.lineWidth = 2;
    roundRectStroke(ctx, 6, 6, W-12, H-12, 10);

    // ãƒ—ãƒ¬ã‚¤ã‚¨ãƒªã‚¢æ 
    ctx.strokeStyle = '#2a2a2a';
    ctx.lineWidth = 1.5;
    roundRectStroke(ctx, playX, playY, playW, playH, 8);

    // å³å‡¡ä¾‹ã‚¨ãƒªã‚¢æ 
    ctx.strokeStyle = '#2a2a2a';
    roundRectStroke(ctx, legend.x, playY, legend.w, playH, 8);

    // ä¸Šæ®µã®æ¨ªãƒ©ã‚¤ãƒ³ï¼ˆæŒ‡ç¤º/å®¢ã®ä¸‹ã‚ãŸã‚Šï¼‰
    ctx.strokeStyle = '#242424';
    ctx.setLineDash([4,6]);
    ctx.beginPath();
    ctx.moveTo(playX + 8, customerRowY + 28);
    ctx.lineTo(playX + playW - 8, customerRowY + 28);
    ctx.stroke();
    ctx.setLineDash([]);

    // ç¸¦ãƒ¬ãƒ¼ãƒ³ç‚¹ç·šï¼ˆãƒ©ãƒ•ã®ç¸¦ã‚¬ã‚¤ãƒ‰ï¼‰
    for (const lg of lanesGeo){
      ctx.strokeStyle = '#262626';
      ctx.setLineDash([6,10]);
      ctx.beginPath();
      ctx.moveTo(lg.centerX, customerRowY + 28);
      ctx.lineTo(lg.centerX, lg.bottomY);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // æŒ‡ç¤ºæ–‡å­—ï¼ˆä¸Šæ®µï¼‰
    for (let i=0;i<LANE_COUNT;i++){
      const lg = lanesGeo[i];
      const order = lanes[i].order;
      ctx.fillStyle = '#ddd';
      ctx.font = '20px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(order.target, lg.centerX, headerLineY);
    }

    // å®¢ã‚¢ã‚¤ã‚³ãƒ³ï¼ˆãã®ä¸‹ã®è¡Œï¼‰
    for (let i=0;i<LANE_COUNT;i++){
      const lg = lanesGeo[i];
      const order = lanes[i].order;

      // é¡”å††
      ctx.fillStyle = '#191919';
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(lg.centerX, customerRowY, 24, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // é¡”ï¼ˆçµµæ–‡å­—ï¼‰
      ctx.font = '20px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#f2f2f2';
      ctx.fillText(order.customer.icon, lg.centerX, customerRowY+1);
      ctx.textBaseline = 'alphabetic';

      // å°ã•ã„å¾…ã¡æ™‚é–“
      ctx.fillStyle = '#999';
      ctx.font = '11px sans-serif';
      ctx.fillText(`${order.patience.toFixed(1)}s`, lg.centerX, customerRowY + 42);
    }

    // ã¦ã¼ï¼ˆä¸‹æ®µï¼‰
    for (let i=0;i<LANE_COUNT;i++){
      const lg = lanesGeo[i];
      const b = lg.basket;

      ctx.fillStyle = '#141414';
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 2;
      roundRectFillStroke(ctx, b.x, b.y, b.w, b.h, 8);

      ctx.fillStyle = '#d8d8d8';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`ã¦ã¼ ${i+1}`, b.cx, b.y + 22);

      // ã¦ã¼å†…ã®éºº
      for (const n of lanes[i].noodlesInBasket){
        const h = hardnessByTime(n.cook);
        ctx.fillStyle = h.color;
        ctx.beginPath();
        ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
        ctx.fill();

        if (h.just){
          ctx.strokeStyle = '#fff';
          ctx.globalAlpha = 0.35;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(n.x, n.y, n.r+3, 0, Math.PI*2);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }
    }

    // æ’å‡ºå£ï¼ˆå³ä¸­æ®µï¼‰
    ctx.fillStyle = '#2d2d2d';
    ctx.strokeStyle = '#777';
    ctx.lineWidth = 1.5;
    ctx.fillRect(spout.x, spout.y, spout.w, spout.h);
    ctx.strokeRect(spout.x, spout.y, spout.w, spout.h);

    ctx.fillStyle = '#ddd';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('ã‚ã‚“å‡ºã‚‹', spout.x - 8, spout.y + 13);

    // æ’å‡ºä¸­ã®éºº
    if (activeNoodle){
      ctx.fillStyle = '#f4f4f4';
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(activeNoodle.x, activeNoodle.y, activeNoodle.r, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    }

    // é£›è¡Œéººï¼ˆä¸­å¤®ã‚’é£›ã³äº¤ã†ï¼‰
    for (const f of flying){
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
      ctx.fill();
    }

    // å³å´ï¼šç¡¬ã•è‰²å‡¡ä¾‹ï¼ˆãƒ©ãƒ•å³æ¬„ï¼‰
    drawLegend(legend);

    // ã‚²ãƒ¼ãƒ çµ‚äº†
    if (timeLeft <= 0){
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff';
      ctx.font = '28px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('æ™‚é–“çµ‚äº†', W/2, H/2 - 10);
      ctx.font = '18px sans-serif';
      ctx.fillText(`ã‚¹ã‚³ã‚¢ ${score}`, W/2, H/2 + 24);
    }
  }

  function drawLegend(legend){
    const x = legend.x + 10;
    const y = legend.y + 14;
    const w = legend.w - 20;

    ctx.fillStyle = '#ddd';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('ç¡¬ã•è‰²', x, y);

    const rows = [
      { label:'ã‹ãŸ', color: HARDNESS_TABLE[0].color },
      { label:'æ™®',   color: HARDNESS_TABLE[1].color },
      { label:'ã‚„ã‚', color: HARDNESS_TABLE[2].color },
      { label:'ã®ã³', color: COLOR_NOBI },
    ];

    let cy = y + 28;
    for (const r of rows){
      ctx.fillStyle = r.color;
      ctx.fillRect(x, cy-12, 18, 12);
      ctx.strokeStyle = '#555';
      ctx.strokeRect(x, cy-12, 18, 12);

      ctx.fillStyle = '#ddd';
      ctx.font = '14px sans-serif';
      ctx.fillText(`${r.label} â—‹è‰²`, x + 28, cy - 1);
      cy += 28;
    }

    cy += 8;
    ctx.fillStyle = '#aaa';
    ctx.font = '12px sans-serif';
    ctx.fillText('ç™½ã„è¼ª = ã‚¸ãƒ£ã‚¹ãƒˆ', x, cy);
  }

  // ========= å›³å½¢ãƒ˜ãƒ«ãƒ‘ãƒ¼ =========
  function roundRectStroke(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    ctx.stroke();
  }
  function roundRectFillStroke(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }

  // ========= ãƒ«ãƒ¼ãƒ— =========
  function frame(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    t += dt;

    update(dt);
    draw();

    requestAnimationFrame(frame);
  }

  // ========= ãƒœã‚¿ãƒ³ =========
  ui.resetBtn.addEventListener('click', () => resetGame());

  ui.adBtn.addEventListener('click', () => {
    // ä»®ï¼šã¦ã¼1ã‚’è£œåŠ©
    lanes[0].auto.enabled = true;
    lanes[0].auto.timeLeft = 12;
    lanes[0].auto.usesLeft = 6;
    log('ã‚¢ãƒ«ãƒã‚¤ãƒˆï¼ˆä»®ï¼‰ï¼šã¦ã¼1ã‚’è£œåŠ©');
  });

  // ========= é–‹å§‹ =========
  resetGame();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
